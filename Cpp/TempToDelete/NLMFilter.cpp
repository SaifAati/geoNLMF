
#include <float.h>//For "_isnan" function.
#include <limits>//For quiet_nan() function
#include <cmath>
#include <cstdio>

//#include <ipp.h> // Intel Integrated Performance Primitives
#include <omp.h> // OpenMP threading : sudo apt-get install libomp-dev

#include <xmmintrin.h>//Need this for SSE intrinsics
#include <emmintrin.h>//Need this for SSE2 intrinsics.

#include "Include/NLMFilter.h"
//#include "export.h"


#include <iostream>
// Constructors:
CNLMFilter::CNLMFilter() {
    // Set the number of iterations to use for the Intel IPP SVD function.
    svdIterations = 9;

    // Set the number of doubling iterations for use with the IPP SVD function.
    // This is used in case the function fails to converge after the default
    // number of iterations (svdIterations). In this case, a new number of iterations
    // is generated by computing integer multiples of svdIterations. For example,
    // svdIterations = 9. Fail to converge? svdIterations = 18...fail? svdIterations = 27, etc.
    svdIterationsMaxMultiple = 3;

    // Set the epsilon applied to the "W" array after the SVD operation:
    svd_W_epsilon = 10e-06;
}

void CNLMFilter::SetSearchSize(int size) {
    //Store the search size:
    SearchSize = size;
}

void CNLMFilter::SetWindowSize(int size) {
    //Store the window size:
    WindowSize = size;
}

int CNLMFilter::GetWindowSize() {
    return WindowSize;
}

void CNLMFilter::StoreWeightingFunctionType(int type) {
    //Store the weighting function type integer:
    WeightingFunctionType = type;
}

void CNLMFilter::StoreMinNumberOfWeights(int number) {
    //Store the minimum number of weights:
    MinNumberOfWeights = number;
}

void CNLMFilter::StoreMinimumWeightValue(double value) {
    //Store the minimum weight threshold value:
    MinimumWeightThreshold = value;
}

double CNLMFilter::GetMinimumWeightThreshold() {
    // Return the minimum weight threshold value:
    return MinimumWeightThreshold;
}

void CNLMFilter::StoreLinearFitOption(int selection) {
    //Store the boolean:
    UseLinearFit = selection;
}

void CNLMFilter::StoreAdaptiveHoption(int selection) {
    //Store the integer selection:
    UseAdaptiveH = selection;
}

void CNLMFilter::StoreSNRWeightingOption(int selection) {
    //Store the SNR weighting int (yes = 1, no = 0):
    UseSNRdata = selection;
}

bool CNLMFilter::UsesSNRdata() {
    // Return the SNR data selection (true or false):
    bool returnBool;
    if (UseSNRdata == 1) { returnBool = true; }
    else { returnBool = false; }

    return returnBool;
}

void CNLMFilter::StoreCenterPointOption(int selection) {
    //Store the center point option (1 = include, 0 = omit):
    CenterPointInclusive = selection;
}

void CNLMFilter::StoreHparam(double h) {
    //Store the noise estimation:
    Hparam = h;
    std::cout<<"the noise estimation:"<<Hparam<<std::endl;
}

void CNLMFilter::SetDataWidth(int width) {
    //Store the data width:
    DataWidth = width;
}

void CNLMFilter::SetDataHeight(int height) {
    //Store data height:
    DataHeight = height;
}

int CNLMFilter::GetDataHeight() {
    return DataHeight;
}

int CNLMFilter::GetDataWidth() {
    return DataWidth;
}

void CNLMFilter::ComputeOutputDimensions() {
    //compute the dimensions of the output array minus the
    //unfiltered edges:
    int EdgeWidth = WindowSize / 2; //Use int truncation.
    OutputHeight = DataHeight - (2 * EdgeWidth);
    OutputWidth = DataWidth - (2 * EdgeWidth);
    std::cout<<"oDim:"<< OutputHeight<<","<<OutputWidth<<std::endl;
}

void CNLMFilter::AllocateNaNMask() {
    //Allocate the NaNMask (align on 16-byte boundary):
    NaNMask = (unsigned char *) _mm_malloc((DataWidth * DataHeight), 16);
}

void CNLMFilter::StoreInputArrayPtr_Float(float *inputPtr)
{
    //Store the input array pointer:
    InputData_F = inputPtr;
    //std::cout<<*(InputData_F+245)<<std::endl;
}
void CNLMFilter::StoreOutputArrayPtr_Float(float *outputPtr) {
    //Store the output array pointer:
    OutputData_F = outputPtr;
//    std::cout<<*(OutputData_F+1)<<std::endl;
}


void CNLMFilter::ComputeGaussianWindow_Float() {
    //NOTE: The normalization of the gaussian occurs in the filtering thread
    //function in order to normalize a gaussian that has values which spatially
    //correspond to NaN values in the original unfiltered data.

    //Calculate the StdDev based on the user-input window size:
    float sigma = (((float) WindowSize) - 1.0f) / 2.0f;
    std::cout<<"sigma:"<<sigma<<" ";
    //Allocate a 2d (it's easier to compute) float array to hold the
    //gaussian kernel filter coefficients:
    float **GaussianKernel;
    GaussianKernel = new float *[WindowSize];//Rows.
    for (int row = 0; row < WindowSize; row++) {
        GaussianKernel[row] = new float[WindowSize];//Columns.
    }

    //Loop through the array, compute and store the Gaussian coefficients:
    int WindowCenter = WindowSize / 2;

    for (int row = 0; row < WindowSize; row++) {
        for (int column = 0; column < WindowSize; column++) {
            //Compute distance from center of kernel window:
            float RowDistance = (float) (WindowCenter - row);
            float ColumnDistance = (float) (WindowCenter - column);
            float Distance = sqrt((RowDistance * RowDistance) + (ColumnDistance * ColumnDistance));

            //Compute coefficient based on distance and StdDev:
            GaussianKernel[row][column] = expf(-0.5f * ((Distance / sigma) * (Distance / sigma)));
        }
    }

    //Check the center point included option. If excluded,
    //set the inner gaussian value to zero:
    if (CenterPointInclusive == 0) {
        int center = WindowSize / 2;//Use integer truncation.
        GaussianKernel[center][center] = 0.0f;
    }

    //Allocate the 1D memory array, aligned on 16-byte boundary. This
    //consists of the gaussian coefficients plus the zero buffering needed
    //for the vectorization. Each vector consists of 4 floats, so to
    //compute the buffer size, divide the total number of window elements
    //by 4 and round up to the next integer:
    float NumberOfBufferedElements = (float) (WindowSize * WindowSize);
    int NumberOfVectors = (int) (ceil(NumberOfBufferedElements / 4.0f));

    GaussianWindow_F = (float *) _mm_malloc((NumberOfVectors * 4 * 4), 16);

    //Loop through and load buffer with zeros:
    int Position = 0;
    for (int x = 0; x < (NumberOfVectors * 4); x++) {
        *(GaussianWindow_F + Position) = 0.0f;
        Position++;
    }

    //Loop through and load the gaussian values:
    Position = 0;
    for (int row = 0; row < WindowSize; row++)//"column" is correct.
    {
        for (int column = 0; column < WindowSize; column++)//"row" is correct.
        {
            *(GaussianWindow_F + Position) = GaussianKernel[row][column];
            Position++;
        }
    }


    //Deallocate temporary GaussianKernel memory:
    for (int x = 0; x < WindowSize; x++) {
        delete[] GaussianKernel[x];
    }
    delete[] GaussianKernel;
}

int CNLMFilter::GetOutputHeight() {
    return OutputHeight;
}

int CNLMFilter::GetOutputWidth() {
    return OutputWidth;
}

float *CNLMFilter::GetInputArrayPtr_Float() {
    return InputData_F;
}

float *CNLMFilter::GetOutputArrayPtr_Float() {
    return OutputData_F;
}

void CNLMFilter::StoreSNRArrayPtr_Float(float *snrPtr) {

    //Store the SNR array pointer:
    SNR_F = snrPtr;
}




void CNLMFilter::AllocateSNRMask() {
    //Allocate the SNRMask (align on 16-byte boundary):
    SNRMask = (unsigned char *) _mm_malloc((DataWidth * DataHeight), 16);

}


void CNLMFilter::GetSearchLimits(int XPos, int YPos, int SearchDimension, int dataWidth,
                                 int dataHeight, int *left, int *top) {
    //We need to determine the physical extents of the search area
    //i.e. the coords in the data matrix (actually only the left and top) based
    //on the current position in the data matrix and the edge dimension
    //of the user-specified search area. There are 9 possibilities.
    //Use a series of "if-else" statements to determine which one we
    //are dealing with and set the search limits. Note: ALL COORDS
    //ARE DATA ARRAY COORDS!:

    int SearchEdgeDim = SearchDimension / 2;//Use int truncation.

    if ((XPos <= SearchEdgeDim) && (YPos <= SearchEdgeDim))//Possibility 1
    {
        //The upper left corner up to and including the first
        //position wherein the search area will increment along
        //with the X and Y pos.
        *(left) = 0;
        *(top) = 0;
    } else if (((XPos > SearchEdgeDim) && (XPos < (dataWidth - SearchEdgeDim - 1))) &&
               (YPos <= SearchEdgeDim))//Possibility 2
    {
        //The upper middle portion wherein the search area slides
        //horizontally, but not vertically, with the filtering window:
        *(left) = (XPos - SearchEdgeDim);
        *(top) = 0;
    } else if ((XPos >= (dataWidth - SearchEdgeDim - 1)) && (YPos <= SearchEdgeDim))//Possibility 3
    {
        //The upper right corner where the search window cannot slide
        //with the filtering window:
        *(left) = (dataWidth - SearchEdgeDim * 2 - 1);
        *(top) = 0;
    } else if ((XPos <= SearchEdgeDim) && ((YPos > SearchEdgeDim) &&
                                           (YPos < (dataHeight - SearchEdgeDim - 1))))//Possibility 4.
    {
        //The middle left portion where the search window increments vertically
        //but not horizontally with the sliding filter window:
        *(left) = 0;
        *(top) = (YPos - SearchEdgeDim);
    } else if (((XPos > SearchEdgeDim) && (XPos < (dataWidth - SearchEdgeDim - 1))) &&
               ((YPos > SearchEdgeDim) && (YPos < (dataHeight - SearchEdgeDim - 1))))//Possibility 5.
    {
        //The middle of the data array, where the search window shifts with the filtering
        //window.
        *(left) = (XPos - SearchEdgeDim);
        *(top) = (YPos - SearchEdgeDim);
    } else if ((XPos >= (dataWidth - SearchEdgeDim - 1)) &&
               ((YPos > SearchEdgeDim) && (YPos < (dataHeight - SearchEdgeDim - 1))))//Possibility 6.
    {
        //The middle right-hand portion of the array, where the search area can increment
        //vertically but not horizontally:
        *(left) = (dataWidth - SearchEdgeDim * 2 - 1);
        *(top) = (YPos - SearchEdgeDim);
    } else if ((XPos <= SearchEdgeDim) && (YPos >= (dataHeight - SearchEdgeDim - 1)))//Possibility 7
    {
        //The lower left hand portion of the array, where the search area cannot increment
        //with the filtering window:
        *(left) = 0;
        *(top) = (dataHeight - SearchEdgeDim * 2 - 1);
    } else if (((XPos > SearchEdgeDim) && (XPos < (dataWidth - SearchEdgeDim - 1))) &&
               (YPos >= (dataHeight - SearchEdgeDim - 1)))//Possibility 8
    {
        //The bottom middle portion of the data array, where the search area can increment
        //horizontally with the filter window but not vertically:
        *(left) = (XPos - SearchEdgeDim);
        *(top) = (dataHeight - SearchEdgeDim * 2 - 1);
    } else//Possibility 9
    {
        //The lower right portion of the data array, where the search area cannot
        //increment with the filtering window:
        *(left) = (dataWidth - SearchEdgeDim * 2 - 1);
        *(top) = (dataHeight - SearchEdgeDim * 2 - 1);
    }
}

void CNLMFilter::GenerateNaNMask_Float() {
    //Acquire a scanline for processing:
    int Row;
    #pragma omp critical
    {
        Row = synchronizationCounter; // Acquire counter value.
        synchronizationCounter++; // Increment counter.
    }

    while (Row < DataHeight) {
        for (int Column = 0; Column < DataWidth; Column++) {
            //Get the filterData value and check for NaN condition:
            if (__isnan(InputData_F[(Row * DataWidth) + Column])) {
                //Value is NaN. Set the value in the mask to 0:
                NaNMask[(Row * DataWidth) + Column] = 0;

                //Replace the unfiltered NaN with zero:
                InputData_F[(Row * DataWidth) + Column] = 0.0f;
            } else {
                NaNMask[(Row * DataWidth) + Column] = 1;
            }
        }

        //Acquire another scanline for processing:
    #pragma omp critical
        {
            Row = synchronizationCounter; // Acquire counter value.
            synchronizationCounter++; // Increment counter.
        }
    }
}


void CNLMFilter::ReplaceNaNValsInSNRArray_Float() {
    //Grab a scanline for processing:
    int Row;
#pragma omp critical
    {
        Row = synchronizationCounter;
        synchronizationCounter++;
    }

    while (Row < DataHeight) {
        for (int Column = 0; Column < DataWidth; Column++) {
            //Get the filterData value and check for NaN condition:
            if (__isnan(SNR_F[(Row * DataWidth) + Column])) {
                //Value is NaN. Replace the value with 0.0f:
                SNR_F[(Row * DataWidth) + Column] = 0.0f;

                //Set the mask with 0 to indicate presence of a NaN:
                SNRMask[(Row * DataWidth) + Column] = 0;
            } else {
                //Set the value in the mask to 1:
                SNRMask[(Row * DataWidth) + Column] = 1;
            }
        }

        //Grab the next scanline for processing:
#pragma omp critical
        {
            Row = synchronizationCounter;
            synchronizationCounter++;
        }
    }
}

void CNLMFilter::FloatFilter() {

    //Allocate two 1D array of 32-bit floats to hold the filtering window and
    //gaussian values. Buffer this array so that it is a multiple of 4 for SSE:
//    __declspec(align(16)) int NumberOfWindowElements = WindowSize * WindowSize;
    int NumberOfWindowElements = WindowSize * WindowSize;
//    __declspec(align(16)) int BufferedNumberOfVectors = (int) ceil(((float) (WindowSize * WindowSize)) / 4.0f);
    __attribute__((aligned(16))) int BufferedNumberOfVectors = (int) ceil(((float) (WindowSize * WindowSize)) / 4.0f);

    float *SlidingWindow = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4), 16);//Sliding window.
    float *NaNMaskWindow = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4), 16);//Sliding window NaN mask.
    float *BackgroundWindow = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4),
                                                   16);//Background values in scanline.
    float *GaussianWindow = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4), 16);//Gaussian window.
    float *NaNNormalizedGaussian = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4),
                                                        16);//Gaussian normalized for SNR & NaN "holes".
    float *NaNMaskBackground = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4),
                                                    16);//NaN mask for background window.
    float *Register = (float *) _mm_malloc((4 * 4), 16);//For summing across register.

    //Load the gaussian values from the filterData object to this local array:
    float *GaussianPtr = GaussianWindow_F;

    for (int x = 0; x < (BufferedNumberOfVectors * 4); x++)
    {
        *(GaussianWindow + x) = *(GaussianPtr + x);
    }

    //Loop through and load the buffers with zeros:
    for (int x = 0; x < (BufferedNumberOfVectors * 4); x++)
    {
        *(SlidingWindow + x) = 0.0f;
        *(NaNMaskWindow + x) = 0.0f;
        *(BackgroundWindow + x) = 0.0f;
        *(NaNMaskBackground + x) = 0.0f;
        *(NaNNormalizedGaussian + x) = 0.0f;
    }

    //Declare variables to store the running totals used in the final step
    //of the filtering algorithm:
    //__declspec(align(16)) float IterationsSum;
    __m128 IterationsSum;

    __attribute__((aligned(16))) float Temp;
    __attribute__((aligned(16))) float WeightValueSum = 0.0f;
    __attribute__((aligned(16))) float WeightValue = 0.0f;
    __attribute__((aligned(16))) float ScalarValue3Sum = 0.0f;

    //Precompute a coefficient you'll need during the filtering operation:
    __attribute__((aligned(16))) float hOrig = (float) Hparam;
    float NegOne = -1.0f;
    float Two = 2.0f;
    float Zero = 0.0f;
    float one = 1.0f;
    float Hval = (float) Hparam;

    __m128 hOriginal = _mm_load_ss(&hOrig);
    __m128 h = _mm_load_ss(&Hval);
    __m128 hSquared = _mm_mul_ss(h, h);
    __m128 coefficient = _mm_div_ss(_mm_load_ss(&NegOne), _mm_mul_ss(hSquared, _mm_load_ss(&Two)));

    //Declare some vectors to be used with the scalar SIMD instructions:

    __m128 StandardDeviation = _mm_load_ss(&Zero);
    __m128 N = _mm_load_ss(&Zero);
    __m128 Mean = _mm_load_ss(&Zero);
    __m128 One = _mm_load_ss(&one);


    //Declare variables used to synchronize threads and control the loops:
    __attribute__((aligned(16))) int CurrentScanline;
    __attribute__((aligned(16))) int TotalScanlines = OutputHeight;
    __attribute__((aligned(16))) int NumberOfHorizontalShifts = OutputWidth;
    __attribute__((aligned(16))) int EdgeWidth = WindowSize / 2;//Use integer truncation;
    __attribute__((aligned(16))) int SearchEdgeWidth = SearchSize / 2;//Use integer truncation.

    //Compute the number of vertical and horizontal shifts the filtering window
    //makes within the search area:
    __attribute__((aligned(16))) int NumberOfHSearchShifts = SearchSize - (EdgeWidth * 2);
    __attribute__((aligned(16))) int NumberOfVSearchShifts = NumberOfHSearchShifts;

    //Declare variables for the search area limits:
    __attribute__((aligned(16))) int Left, Top, dataHeight, dataWidth;
    dataHeight = DataHeight;
    dataWidth = DataWidth;

    //Some SSE filterData type vectors we'll need:
    __m128 filterVec, backgroundVec, gaussianVec, result1, result2,
            nanWindowVec, gaussianSum;

    //Used for the SV-decomposition solution of linear equations in the Intel IPP library:
    double A[3 * 3];
    double U[3 * 3];
    double U_transposed[3 * 3];
    double V[3 * 3];
    double W[3];
    double Wt[3 * 3];
    double Temp1[3 * 3];
    double Temp2[3 * 3];
    double B[3];
    double X[3];
    int srcStride2_64 = sizeof(double);
    int srcStride1_64 = 3 * sizeof(double);
    int decompStride1 = 3 * sizeof(float);
    int decompStride2 = sizeof(float);

    for (int x = 0; x < 9; x++)
    {
        Wt[x] = 0.0;
    }

    __attribute__((aligned(16))) float OriginalNoisyValue;

    //Store the weighting type for use later:
    __attribute__((aligned(16))) int WeightingType = WeightingFunctionType;

    //Store the linear fit bool:
    bool UsingLinearFitOption = false;
    if (UseLinearFit > 0)
    {
        UsingLinearFitOption = true;
        std::cout<<"Using Linear Fit Option: "<<UsingLinearFitOption<<std::endl;

    }

    //__declspec(align(16)) float MinimumWeightThreshold = (float)MinimumWeightThreshold;
    __attribute__((aligned(16))) int WeightNumberThreshold = MinNumberOfWeights;

    //Center of Gaussian array:
    __attribute__((aligned(16))) int GaussianCenterOffset = ((WindowSize * WindowSize) - 1) / 2;

    //Grab a scanline for processing:
    #pragma omp critical
    {
        CurrentScanline = synchronizationCounter;
        synchronizationCounter++;
    }

    //unsigned char* NaNMask = NaNMask;
    float *UnfilteredData = InputData_F;
    float *FilteredData = OutputData_F;


    //Loop over filterData and filter:
//    std::cout<< "TotalScanlines:"<<TotalScanlines<<std::endl;
//    TotalScanlines = 1;
    while (CurrentScanline < TotalScanlines)
    {
        //Set the coordinate of the center of the filtering window
        //based on the scanline. A scanline of value 0 starts at
        //the row equal to the edge width in the original filterData array:
        int Row = CurrentScanline;

        //Loop over the scanline, extracting the filter windows
        //and sliding them across the background search area, filtering:

        for (int Column = 0; Column < NumberOfHorizontalShifts; Column++)
        {
            //Check to see if the current value is NaN.
            //If so..bypass:
            unsigned char NaNMaskValue = *(NaNMask + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth));

            if (NaNMaskValue > 0)
            {
                //Extract the filtering window and it's associated NaN mask
                // and SNR window based on the row and column centers.
                int increment = 0;
                for (int row = 0; row < WindowSize; row++)
                {
                    for (int column = 0; column < WindowSize; column++) {
                        *(SlidingWindow + increment) = *(UnfilteredData + ((Row + row) * DataWidth) +
                                                         (Column + column));
                        *(NaNMaskWindow + increment) = (float) (*(NaNMask + ((Row + row) * DataWidth) +
                                                                  (Column + column)));
                        increment++;
                    }
                }
//
                //Check to see if user has selected "adaptive H" option:
                if (UseAdaptiveH > 0)
                {
                    //They are. Reset the adaptive variables:
                    //N                 = 0.0f;
                    //Mean              = 0.0f;
                    //StandardDeviation = 0.0f;
                    _mm_store_ss(&Zero, N);
                    _mm_store_ss(&Zero, Mean);
                    _mm_store_ss(&Zero, StandardDeviation);

                    //Compute the total number of non-NaN values in the current
                    //filtering window by summing over the NaN mask (in the mask, NaN
                    //values are equal to 0, cast to float in NaNMaskWindow):
                    for (int x = 0; x < (WindowSize * WindowSize); x++) {
                        if (*(NaNMaskWindow + x) > 0.0f) {
                            //N += 1.0f;//Number of non-NaNs.
                            //Mean += *(SlidingWindow + x);//Running total.
                            N = _mm_add_ss(N, One);
                            Mean = _mm_add_ss(Mean, _mm_load_ss(SlidingWindow + x));
                        }
                    }

                    //Compute window mean:
                    //Mean = Mean / (N*N);
                    Mean = _mm_div_ss(Mean, _mm_mul_ss(N, N));

                    //Loop through and compute the standard deviation,
                    //again checking for NaNs using the NaN mask:
                    for (int x = 0; x < (WindowSize * WindowSize); x++) {
                        if (*(NaNMaskWindow + x) > 0.0f) {
                            //float value = *(SlidingWindow + x);
                            //StandardDeviation += (Mean - value)*(Mean - value);
                            __m128 value = _mm_load_ss(SlidingWindow + x);
                            StandardDeviation =
                                    _mm_add_ss(StandardDeviation,
                                               _mm_mul_ss(_mm_sub_ss(Mean, value), _mm_sub_ss(Mean, value)));
                        }
                    }

                    //Final StdDev value for this sliding window:
                    //StandardDeviation = StandardDeviation * (1.0f / (N*N - 1.0f));
                    StandardDeviation = _mm_mul_ss(StandardDeviation,
                                                   _mm_div_ss(One, _mm_sub_ss(_mm_mul_ss(N, N), One)));

                    //Recompute h, hSquared, and coefficient:
                    //h           = hOriginal * (sqrt(StandardDeviation));
                    //hSquared    = h * h;
                    //coefficient = -1.0f / (2.0f * (hSquared));
                    h = _mm_mul_ss(hOriginal, _mm_sqrt_ss(StandardDeviation));
                    hSquared = _mm_mul_ss(h, h);
                    coefficient =
                            _mm_div_ss(_mm_load_ss(&NegOne), _mm_mul_ss(_mm_load_ss(&Two), hSquared));

                }//End of "if UsingAdaptiveH" block.

                //Reset the running sum variables to zero:
                WeightValueSum = 0.0f;
                ScalarValue3Sum = 0.0f;

                //Get the search area limits based on the current filtering pixel.
                //(In hindsight I only needed the left and top values):
                GetSearchLimits(Column + EdgeWidth, Row + EdgeWidth, SearchSize, DataWidth,
                                DataHeight, &Left, &Top);

                //Initialize the weight counter and threshold:
                int NumberOfWeightsAboveThreshold = 0;

                // Initialize to zero:
                for (int pos = 0; pos < 9; pos++)
                {
                    A[pos] = 0.0f;
                }
                B[0] = 0.0f;
                B[1] = 0.0f;
                B[2] = 0.0f;

                //Loop over search area, sliding window and filtering:
                for (int VPosition = 0; VPosition < NumberOfVSearchShifts; VPosition++)
                {
                    for (int HPosition = 0; HPosition < NumberOfHSearchShifts; HPosition++)
                    {

                        //Check for the presence of a NaN at the center of the
                        //background search patch. Bypass filtering operation
                        //if NaN is present:
                        float CenterValue =
                                (float) (*(NaNMask + ((Top + VPosition + EdgeWidth) * DataWidth) +
                                           (Left + HPosition + EdgeWidth)));



                        if (CenterValue > 0.0f)
                        {
//                            std::cout<<"CenterValue:"<<CenterValue<<" ";
                            //Extract background window and NaN mask into array (NaNMaskWindow
                            //was extracted earlier):
                            increment = 0;
                            for (int row = 0; row < WindowSize; row++)
                            {
                                for (int column = 0; column < WindowSize; column++) {
                                    *(BackgroundWindow + increment) =
                                            *(UnfilteredData + ((Top + VPosition + row) * DataWidth) +
                                              (Left + HPosition + column));

                                    *(NaNMaskBackground + increment) =
                                            (float) (*(NaNMask + ((Top + VPosition + row) * DataWidth) +
                                                       (Left + HPosition + column)));

                                    increment++;
                                }
                            }

                            //Normalize the Gaussian kernel to the sum of all the gaussian
                            //values in the kernel that do not correspond to a NaN value in
                            //either the background NaN mask or the window NaN mask.
                            //Use SSE (exclude SSE3 summing across register instruction):
                            float GaussianNormalizationTerm = 0.0f;
                            for (int x = 0; x < NumberOfWindowElements; x += 4)
                            {
                                //Combine NaN masks with bitwise AND operation. Just use the
                                //nanWindowVec variable:
                                nanWindowVec =
                                        _mm_and_ps(_mm_load_ps(NaNMaskWindow + x), _mm_load_ps(NaNMaskBackground + x));

                                //Multiply the Gaussian by the NaN mask to filter with NaN:
                                gaussianVec =
                                        _mm_mul_ps(_mm_load_ps(GaussianWindow + x), nanWindowVec);

                                //Store this result to the gaussian buffer for use later, and
                                //extract and sum (no SSE3) to normalize:
                                _mm_store_ps(Register, gaussianVec);//for accumulation
                                _mm_store_ps((NaNNormalizedGaussian + x), gaussianVec);//For final normalization.

                                //Accumulate:
                                GaussianNormalizationTerm +=
                                        (*(Register) + *(Register + 1) + *(Register + 2) + *(Register + 3));
                            }

                            //Now we have to check to make sure that the gaussian array doesn't consist
                            //of zeros. This is only a concern if the user has opted to exclude the
                            //central value during the processing operation, so check for
                            //that condition first:
                            if (CenterPointInclusive < 1)
                            {
                                //They are excluding the center point, so we have to
                                //check the gaussian and make sure all the elements
                                //sum up to more than zero:
                                int increment = 0;
                                float AccumulatedGaussian = 0.0f;
                                for (int a = 0; a < WindowSize; a++) {
                                    for (int b = 0; b < WindowSize; b++) {
                                        AccumulatedGaussian += *(NaNNormalizedGaussian + increment);
                                        increment++;
                                    }
                                }

                                if (AccumulatedGaussian == 0.0f) {
                                    //Reset the gaussian center point to 1.0f. That means
                                    //that for this particular filterData point in the search area
                                    //it is as if the user has opted to include the center point
                                    //value. This avoids the situation where you have a gaussian
                                    //matrix consisting only of zeros:
                                    *(NaNNormalizedGaussian + GaussianCenterOffset) = 1.0f;

                                    //Change the normalization term to 1.0f to reflect the change:
                                    GaussianNormalizationTerm = 1.0f;
                                }
                            }
                            //std::cout<<"GussianNormalizationTerm:"<<GaussianNormalizationTerm<<" ";
                            //Loop through the gaussian buffer and normalize with the above
                            //term (don't bother checking for zeros, just compute):
                            gaussianSum = _mm_load1_ps(&GaussianNormalizationTerm);//Populate vector
                            for (int x = 0; x < NumberOfWindowElements; x += 4)
                            {
                                //Final normalization:
                                gaussianVec =
                                        _mm_div_ps(_mm_load_ps(NaNNormalizedGaussian + x), gaussianSum);

                                //Store:
                                _mm_store_ps((NaNNormalizedGaussian + x), gaussianVec);
                            }

                            //Initialize the iterations sum variable:
                            //IterationsSum = 0.0f;
                            IterationsSum = _mm_load_ss(&Zero);

                            //Store the original noisy value (at the center of the background window):
                            OriginalNoisyValue =
                                    *(UnfilteredData + ((Top + VPosition + EdgeWidth) * DataWidth) +
                                      (Left + HPosition + EdgeWidth));

                            //Loop over vectorized window and filter:
                            for (int x = 0; x < NumberOfWindowElements; x += 4)
                            {
                                //Load filterData:
                                filterVec = _mm_load_ps(SlidingWindow + x);
                                backgroundVec = _mm_load_ps(BackgroundWindow + x);

                                //Load NaN-normalized / SNR-weighted gaussian:
                                gaussianVec = _mm_load_ps(NaNNormalizedGaussian + x);

                                //compute difference between window and background:
                                result1 = _mm_sub_ps(filterVec, backgroundVec);

                                //Square the difference and multiply by the gaussian:
                                result2 = _mm_mul_ps(gaussianVec, _mm_mul_ps(result1, result1));

                                //Sum result2 across registers (without using SSE3).
                                //First, store in buffer:
                                _mm_store_ps(Register, result2);
                                Temp = 0.0f;

                                //Accumulate:
                                Temp +=
                                        (*(Register) + *(Register + 1) + *(Register + 2) + *(Register + 3));

                                //Add iteration sum to running sum:
                                //IterationsSum += Temp;
                                IterationsSum = _mm_add_ss(IterationsSum, _mm_load_ss(&Temp));

                            }//End of window element loop.

                            //Next step is to compute the weight value according to
                            //the user selection:

                            if (WeightingType == 1)//Standard
                            {
                                float temp;
                                _mm_store_ss(&temp, _mm_mul_ss(coefficient, IterationsSum));
                                WeightValue = expf(temp);
                            } else if (WeightingType == 2)//Bisquare
                            {
                                //float r = sqrt(IterationsSum);
                                float r;
                                _mm_store_ss(&r, _mm_sqrt_ss(IterationsSum));

                                //compare against the noise parameter value "h":
                                float hCompare;
                                _mm_store_ss(&hCompare, h);

                                if (r <= hCompare) {
                                    //Compute weight via Bisquare method:
                                    //WeightValue =
                                    //	(1.0f - (IterationsSum/hSquared))*(1.0f - (IterationsSum/hSquared));
                                    __m128 Term = _mm_sub_ss(One, _mm_div_ss(IterationsSum, hSquared));
                                    _mm_store_ss(&WeightValue, _mm_mul_ss(Term, Term));
                                } else {
                                    //Set to zero:
                                    WeightValue = 0.0f;
                                }
                            } else //Modified Bisquare
                            {
                                //float r = sqrt(IterationsSum);
                                float r;
                                _mm_store_ss(&r, _mm_sqrt_ss(IterationsSum));

                                //compare against the noise parameter value "h":
                                float hCompare;
                                _mm_store_ss(&hCompare, h);

                                if (r <= hCompare) {
                                    //Compute weight via Modified Bisquare method:
                                    float Term;
                                    _mm_store_ss(&Term, _mm_sub_ss(One, _mm_div_ss(IterationsSum, hSquared)));
                                    WeightValue = pow(Term, 8);
                                } else {
                                    //Set to zero:
                                    WeightValue = 0.0f;
                                }
                            }

                            //Check for linear fit option:

                            if (UsingLinearFitOption)
                            {
                                //Compute/accumulate the coefficients:
                                float Coefficient1 = WeightValue * ((float) HPosition);
                                float Coefficient2 = WeightValue * ((float) VPosition);

                                //Accumulate and store values in the "A" matrix (array, actually):
                                A[0] += Coefficient1 * ((float) HPosition);
                                A[1] += Coefficient1 * ((float) VPosition);
                                A[2] += Coefficient1;
                                A[4] += Coefficient2 * ((float) VPosition);
                                A[5] += Coefficient2;
                                A[8] += WeightValue;
                                A[3] = A[1];
                                A[6] = A[2];
                                A[7] = A[5];

                                //Accumulate and store values in the "B" vector:
                                B[0] += Coefficient1 * OriginalNoisyValue;
                                B[1] += Coefficient2 * OriginalNoisyValue;
                                B[2] += WeightValue * OriginalNoisyValue;

                                //Check the weight value against the threshold:
                                if (WeightValue > MinimumWeightThreshold) {
                                    NumberOfWeightsAboveThreshold++;//Increment counter.
                                }

                            }//end of "if UsingLinearFitOption" block.
                            else
                            {
                                //Store to WeightSum:
                                WeightValueSum += WeightValue;

                                //Compute the ScalarValue3 running total for this filtering position:
                                ScalarValue3Sum += (WeightValue * OriginalNoisyValue);
                            }//end of "else averaging" block.

                        }//End of "if CenterValue > 0.0f" block.

                    }//End of "for(int HPosition = 0; ... "
                }//End of "for(int VPosition = 0; ..."


                //check for linear regression fit option:

                if (UsingLinearFitOption)
                {
                    std::cout<<"check for linear regression fit option"<<std::endl;
                    std::cout<<"UsingLinearFitOption:Error with ipp SVD decomposition  "<<std::endl;
//                    if (NumberOfWeightsAboveThreshold >= WeightNumberThreshold)
//                    {
//                        float RelativeXcoord = (float) ((Column + EdgeWidth) - (Left + EdgeWidth));
//                        float RelativeYcoord = (float) ((Row + EdgeWidth) - (Top + EdgeWidth));
//
//                        // Solve the system of 3 linear equations. First,
//                        // perform the SV-decomposition on the "A" matrix. Intel
//                        // only supplies double-precision version of this operation:
//                        IppStatus returnStatus = ippsSVD_64f_D2((const Ipp64f *) A, U, 3, W, V, 3, 3, svdIterations);
//
//                        // Check the return status for the above operation and see if it
//                        // has converged:
//                        bool functionConverged = true;
//                        if (returnStatus == ippStsSVDCnvgErr) {
//                            // Function has failed to converge after the default number
//                            // of iterations. Increase the number of iterations, loop,
//                            // check, repeat if necessary:
//                            functionConverged = false;
//                            int maxNumberOfIterationsToTry = svdIterations * svdIterationsMaxMultiple;
//                            int currentNumberOfIterations = svdIterations * 2;
//
//                            while ((currentNumberOfIterations <= maxNumberOfIterationsToTry) && !functionConverged) {
//                                // Try again with new number of iterations:
//                                returnStatus = ippsSVD_64f_D2((const Ipp64f *) A, U, 3, W, V, 3, 3,
//                                                              currentNumberOfIterations);
//
//                                // Check for convergence:
//                                if (returnStatus == ippStsSVDCnvgErr) {
//                                    // Increase the number of iterations to try:
//                                    currentNumberOfIterations += svdIterations;
//                                } else {
//                                    // Function converged. Set the bool:
//                                    functionConverged = true;
//                                }
//                            }
//                        }
//
//                        // Check for convergence:
//                        if (functionConverged) {
//                            // Check the diagonal values of the "W" array resulting from
//                            // the above SVD operation. If they are smaller than our
//                            // epsilon value, assign zero. Otherwise, invert:
//                            if (W[0] < svd_W_epsilon) {
//                                W[0] = 0.0;
//                            } else {
//                                W[0] = 1.0 / W[0];
//                            }
//                            if (W[1] < svd_W_epsilon) {
//                                W[1] = 0.0;
//                            } else {
//                                W[1] = 1.0 / W[1];
//                            }
//                            if (W[2] < svd_W_epsilon) {
//                                W[2] = 0.0;
//                            } else {
//                                W[2] = 1.0 / W[2];
//                            }
//
//                            // Load these values into Wt vector:
//                            Wt[0] = W[0];
//                            Wt[4] = W[1];
//                            Wt[8] = W[2];
//
//                            // Take the transpose of the U matrix:
//                            returnStatus = ippmTranspose_m_64f((const Ipp64f *) U, srcStride1_64, srcStride2_64,
//                                                               3, 3, U_transposed, srcStride1_64, srcStride2_64);
//
//                            // Multiply the V matrix by the Wt matrix:
//                            returnStatus = ippmMul_mm_64f((const Ipp64f *) V, srcStride1_64, srcStride2_64, 3, 3,
//                                                          (const Ipp64f *) Wt, srcStride1_64, srcStride2_64, 3, 3,
//                                                          Temp1, srcStride1_64, srcStride2_64);
//
//                            // Multiply the result from the above operation by the U transpose:
//                            returnStatus = ippmMul_mm_64f((const Ipp64f *) Temp1, srcStride1_64, srcStride2_64, 3, 3,
//                                                          (const Ipp64f *) U_transposed, srcStride1_64, srcStride2_64,
//                                                          3, 3,
//                                                          Temp2, srcStride1_64, srcStride2_64);
//
//                            // Multiply the result of the above operation by the "B" vector to
//                            // get our equation coefficients:
//                            returnStatus = ippmMul_mv_64f((const Ipp64f *) Temp2, srcStride1_64, srcStride2_64, 3, 3,
//                                                          (const Ipp64f *) B, srcStride2_64, 3,
//                                                          X, srcStride2_64);
//
//
//                            //Compute and store final value using these coefficients
//                            //and the relative (search area) coordinate of the filterData
//                            //point being filtered:
//                            *(FilteredData + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth)) =
//                                    ((float) X[0] * RelativeXcoord) + ((float) X[1] * RelativeYcoord) + (float) X[2];
//
//                        }// End of "if function converged" block.
//                        else {
//                            //Compute using simplified method:
//                            *(FilteredData + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth)) = (float) (B[2] /
//                                                                                                                A[8]);
//                        }
//
//                    } else {
//                        //Compute using simplified method:
//                        *(FilteredData + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth)) = (float) (B[2] /
//                                                                                                            A[8]);
//                    }

                }//End of "if UsingLinearFit" block.
                else
                {
                    //Compute and store final result:
                    *(FilteredData + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth)) =
                            (float) (ScalarValue3Sum / WeightValueSum);
//                    std::cout<<*(FilteredData + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth))<<" ";
                }//End of averaging lock.

            }//End of "if (NanMask[][] == 1.0f) && SNR > 0.0f " block.

            else {
                //Store a NaN at this location since there is either
                //a NaN in the original filterData or the SNR is too low:
                *(FilteredData + ((Row + EdgeWidth) * DataWidth) +
                  (Column + EdgeWidth)) = std::numeric_limits<float>::quiet_NaN();
            }
//            std::cout<<*(FilteredData + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth))<<" ";
        }//End of scanline loop (int Column = 0;...).

        //Get the next scanline for processing:
        #pragma omp critical
        {
            CurrentScanline = synchronizationCounter;
            synchronizationCounter++;
        }

    }//End of filtering loop (while CurrentScanline <= ...).

    //Deallocate memory here:
    _mm_free(SlidingWindow);
    _mm_free(NaNMaskWindow);
    _mm_free(BackgroundWindow);
    _mm_free(GaussianWindow);
    _mm_free(NaNNormalizedGaussian);
    _mm_free(NaNMaskBackground);
    _mm_free(Register);
}


void CNLMFilter::RestoreNaNValsInSNRArray_Float() {
    //Grab a scanline for processing:
    int Row;
#pragma omp critical
    {
        Row = synchronizationCounter; // Acquire counter value.
        synchronizationCounter++; // Increment counter.
    }

    while (Row < DataHeight) {
        for (int Column = 0; Column < DataWidth; Column++) {
            int CurrentPosition = (DataWidth * Row) + Column;

            //Get the filterData value and check for NaN condition:
            if (*(SNRMask + CurrentPosition) == 0) {
                //NaN at this location. Store NaN in output array:
                *(SNR_F + CurrentPosition) = std::numeric_limits<float>::quiet_NaN();
            }
        }

        //Grab the next scanline for processing:
#pragma omp critical
        {
            Row = synchronizationCounter; // Acquire counter value.
            synchronizationCounter++; // Increment counter.
        }
    }
}


void CNLMFilter::PlaceNaNValsInOutputArray_Float() {
    //Scan through the filtered portion of the output array and
    //place a NaN value anywhere there was one originally in the
    //noisy data.
    int Offset = (WindowSize / 2);//Use int truncation.

    //Grab a scanline for processing:
    int Row;
#pragma omp critical
    {
        Row = synchronizationCounter;
        synchronizationCounter++;
    }

    while (Row < OutputHeight) {
        for (int Column = 0; Column < OutputWidth; Column++) {
            int CurrentPosition = ((Offset + Row) * DataWidth) + (Offset + Column);

            //Get the data value and check for NaN condition:
            if (*(NaNMask + CurrentPosition) == 0) {
                //NaN at this location. Store NaN in output array:
                *(OutputData_F + CurrentPosition) = std::numeric_limits<float>::quiet_NaN();
            }
        }

        //Grab the next scanline for processing:
#pragma omp critical
        {
            Row = synchronizationCounter;
            synchronizationCounter++;
        }
    }
}

unsigned char *CNLMFilter::GetNaNMask() {
    return NaNMask;
}



void CNLMFilter::FloatFilter_SNR() {
    //Allocate two 1D array of 32-bit floats to hold the filtering window and
    //gaussian values. Buffer this array so that it is a multiple of 4 for SSE:
    __attribute__((aligned(16))) int NumberOfWindowElements = WindowSize * WindowSize;
    __attribute__((aligned(16))) int BufferedNumberOfVectors = (int) ceil(((float) (WindowSize * WindowSize)) / 4.0f);

    float *SlidingWindow = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4), 16);//Sliding window.
    float *NaNMaskWindow = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4), 16);//Sliding window NaN mask.
    float *SNRSlidingWindow = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4), 16);//SNR filterData.
    float *SNRBackgroundWindow = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4), 16);//SNR filterData.
    float *BackgroundWindow = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4),
                                                   16);//Background values in scanline.
    float *GaussianWindow = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4), 16);//Gaussian window.
    float *NaNSNRNormalizedGaussian = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4),
                                                           16);//Gaussian normalized for SNR & NaN "holes".
    float *NaNMaskBackground = (float *) _mm_malloc((BufferedNumberOfVectors * 4 * 4),
                                                    16);//NaN mask for background window.
    float *Register = (float *) _mm_malloc((4 * 4), 16);//For summing across register.

    //Load the gaussian values from the filterData object to this local array:
    float *GaussianPtr = GaussianWindow_F;

    for (int x = 0; x < (BufferedNumberOfVectors * 4); x++) {
        *(GaussianWindow + x) = *(GaussianPtr + x);
    }

    //Loop through and load the buffers with zeros:
    for (int x = 0; x < (BufferedNumberOfVectors * 4); x++)
    {
        *(SlidingWindow + x) = 0.0f;
        *(NaNMaskWindow + x) = 0.0f;
        *(SNRSlidingWindow + x) = 0.0f;
        *(SNRBackgroundWindow + x) = 0.0f;
        *(BackgroundWindow + x) = 0.0f;
        *(NaNMaskBackground + x) = 0.0f;
        *(NaNSNRNormalizedGaussian + x) = 0.0f;
    }

    //Declare variables to store the runing totals used in the final step
    //of the filtering algorithm:
    //__declspec(align(16)) float IterationsSum;
    __m128 IterationsSum;
    __attribute__((aligned(16))) float Temp;
    __attribute__((aligned(16))) float WeightValueSum = 0.0f;
    __attribute__((aligned(16))) float WeightValue = 0.0f;
    __attribute__((aligned(16))) float ScalarValue3Sum = 0.0f;

    //Precompute a coefficient you'll need during the filtering operation:
    __attribute__((aligned(16))) float hOrig = (float) Hparam;
    float NegOne = -1.0f;
    float Two = 2.0f;
    float Zero = 0.0f;
    float one = 1.0f;
    float Hval = (float) Hparam;

    __m128 hOriginal = _mm_load_ss(&hOrig);
    __m128 h = _mm_load_ss(&Hval);
    __m128 hSquared = _mm_mul_ss(h, h);
    __m128 coefficient = _mm_div_ss(_mm_load_ss(&NegOne), _mm_mul_ss(hSquared, _mm_load_ss(&Two)));

    //Declare some vectors to be used with the scalar SIMD instructions:
    __m128 StandardDeviation = _mm_load_ss(&Zero);
    __m128 N = _mm_load_ss(&Zero);
    __m128 Mean = _mm_load_ss(&Zero);
    __m128 One = _mm_load_ss(&one);


    //Declare variables used to synchronize threads and control the loops:
    __attribute__((aligned(16))) int CurrentScanline;
    __attribute__((aligned(16))) int TotalScanlines = OutputHeight;
    __attribute__((aligned(16))) int NumberOfHorizontalShifts = OutputWidth;
    __attribute__((aligned(16))) int EdgeWidth = WindowSize / 2;//Use integer truncation;
    __attribute__((aligned(16))) int SearchEdgeWidth = SearchSize / 2;//Use integer truncation.

    //Compute the number of vertical and horizontal shifts the filtering window
    //makes within the search area:
    __attribute__((aligned(16))) int NumberOfHSearchShifts = SearchSize - (EdgeWidth * 2);
    __attribute__((aligned(16))) int NumberOfVSearchShifts = NumberOfHSearchShifts;

    //Declare variables for the search area limits:
    __attribute__((aligned(16))) int Left, Top, dataHeight, dataWidth;
    dataHeight = DataHeight;
    dataWidth = DataWidth;

    //Some SSE filterData type vectors we'll need:
    __m128 filterVec, backgroundVec, gaussianVec, result1, result2,
            nanWindowVec, snrWindowVec, gaussianSum;

    //Used for the SV-decomposition solution of linear equations in the Intel IPP library:
    double A[3 * 3];
    double U[3 * 3];
    double U_transposed[3 * 3];
    double V[3 * 3];
    double W[3];
    double Wt[3 * 3];
    double Temp1[3 * 3];
    double Temp2[3 * 3];
    double B[3];
    double X[3];
    int srcStride2_64 = sizeof(double);
    int srcStride1_64 = 3 * sizeof(double);
    int decompStride1 = 3 * sizeof(float);
    int decompStride2 = sizeof(float);

    for (int x = 0; x < 9; x++) {
        Wt[x] = 0.0;
    }

    __attribute__((aligned(16))) float OriginalNoisyValue;

    //Store the weighting type for use later:
    __attribute__((aligned(16))) int WeightingType = WeightingFunctionType;

    //Store the linear fit bool:
    bool UsingLinearFitOption = false;
    if (UseLinearFit > 0) {
        UsingLinearFitOption = true;
    }

    __attribute__((aligned(16))) int WeightNumberThreshold = MinNumberOfWeights;

    //Center of Gaussian array:
    __attribute__((aligned(16))) int GaussianCenterOffset = ((WindowSize * WindowSize) - 1) / 2;

    //Grab a scanline for processing:
#pragma omp critical
    {
        CurrentScanline = synchronizationCounter;
        synchronizationCounter++;
    }

    //	unsigned char* NaNMask = NaNMask;
    //unsigned char* SNRMask = SNRMask;
    float *UnfilteredData = InputData_F;
    float *FilteredData = OutputData_F;
    float *SNRData = SNR_F;

    //Loop over filterData and filter:
    while (CurrentScanline < TotalScanlines)
    {
        //Set the coordinate of the center of the filtering window
        //based on the scanline. A scanline of value 0 starts at
        //the row equal to the edge width in the original filterData array:
        int Row = CurrentScanline;

        //Loop over the scanline, extracting the filter windows
        //and sliding them across the background search area, filtering:

        for (int Column = 0; Column < NumberOfHorizontalShifts; Column++) {
            //Check to see if the current value is NaN, and if
            //the current value has a SNR of 0.0. If not, filter.
            //If so..bypass:
            unsigned char NaNMaskValue = *(NaNMask + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth));
            unsigned char SNRMaskValue = *(SNRMask + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth));
            float SNRDataValue = *(SNRData + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth));

            if ((NaNMaskValue > 0) && (SNRMaskValue > 0) && (SNRDataValue > 0.0f)) {

                //Extract the filtering window and it's associated NaN mask
                // and SNR window based on the row and column centers.
                int increment = 0;
                for (int row = 0; row < WindowSize; row++) {
                    for (int column = 0; column < WindowSize; column++) {
                        *(SlidingWindow + increment) = *(UnfilteredData + ((Row + row) * DataWidth) +
                                                         (Column + column));
                        *(NaNMaskWindow + increment) = (float) (*(NaNMask + ((Row + row) * DataWidth) +
                                                                  (Column + column)));
                        *(SNRSlidingWindow + increment) = *(SNRData + ((Row + row) * DataWidth) + (Column + column));
                        increment++;
                    }
                }

                //Check to see if user has selected "adaptive H" option:
                if (UseAdaptiveH > 0) {
                    //They are. Reset the adaptive variables:
                    _mm_store_ss(&Zero, N);
                    _mm_store_ss(&Zero, Mean);
                    _mm_store_ss(&Zero, StandardDeviation);

                    //Compute the total number of non-NaN values in the current
                    //filtering window by summing over the NaN mask (in the mask, NaN
                    //values are equal to 0, cast to float in NaNMaskWindow):
                    for (int x = 0; x < (WindowSize * WindowSize); x++) {
                        if (*(NaNMaskWindow + x) > 0.0f) {
                            N = _mm_add_ss(N, One);
                            Mean = _mm_add_ss(Mean, _mm_load_ss(SlidingWindow + x));
                        }
                    }

                    //Compute window mean:
                    Mean = _mm_div_ss(Mean, _mm_mul_ss(N, N));

                    //Loop through and compute the standard deviation,
                    //again checking for NaNs using the NaN mask:
                    for (int x = 0; x < (WindowSize * WindowSize); x++) {
                        if (*(NaNMaskWindow + x) > 0.0f) {
                            __m128 value = _mm_load_ss(SlidingWindow + x);
                            StandardDeviation =
                                    _mm_add_ss(StandardDeviation,
                                               _mm_mul_ss(_mm_sub_ss(Mean, value), _mm_sub_ss(Mean, value)));
                        }
                    }

                    //Final StdDev value for this sliding window:
                    StandardDeviation = _mm_mul_ss(StandardDeviation,
                                                   _mm_div_ss(One, _mm_sub_ss(_mm_mul_ss(N, N), One)));

                    //Recompute h, hSquared, and coefficient:
                    h = _mm_mul_ss(hOriginal, _mm_sqrt_ss(StandardDeviation));
                    hSquared = _mm_mul_ss(h, h);
                    coefficient =
                            _mm_div_ss(_mm_load_ss(&NegOne), _mm_mul_ss(_mm_load_ss(&Two), hSquared));

                }//End of "if UsingAdaptiveH" block.

                //Reset the running sum variables to zero:
                WeightValueSum = 0.0f;
                ScalarValue3Sum = 0.0f;

                //Get the search area limits based on the current filtering pixel.
                //(In hindsight I only needed the left and top values):
                GetSearchLimits(Column + EdgeWidth, Row + EdgeWidth, SearchSize, DataWidth,
                                DataHeight, &Left, &Top);

                //Initialize the weight counter and threshold:
                int NumberOfWeightsAboveThreshold = 0;

                // Initialize to zero:
                for (int pos = 0; pos < 9; pos++) {
                    A[pos] = 0.0f;
                }
                B[0] = 0.0f;
                B[1] = 0.0f;
                B[2] = 0.0f;

                //Loop over search area, sliding window and filtering:
                for (int VPosition = 0; VPosition < NumberOfVSearchShifts; VPosition++) {
                    for (int HPosition = 0; HPosition < NumberOfHSearchShifts; HPosition++) {

                        //Check for the presence of a NaN at the center of the
                        //background search patch. Bypass filtering operation
                        //if NaN is present:
                        float CenterValue =
                                (float) (*(NaNMask + ((Top + VPosition + EdgeWidth) * DataWidth) +
                                           (Left + HPosition + EdgeWidth)));

                        if (CenterValue > 0.0f) {
                            //Extract background window, SNR window and NaN mask into array (NaNMaskWindow
                            //was extracted earlier):
                            increment = 0;
                            for (int row = 0; row < WindowSize; row++) {
                                for (int column = 0; column < WindowSize; column++) {
                                    *(BackgroundWindow + increment) =
                                            *(UnfilteredData + ((Top + VPosition + row) * DataWidth) +
                                              (Left + HPosition + column));

                                    *(NaNMaskBackground + increment) =
                                            (float) (*(NaNMask + ((Top + VPosition + row) * DataWidth) +
                                                       (Left + HPosition + column)));

                                    *(SNRBackgroundWindow + increment) =
                                            *(SNRData + ((Top + VPosition + row) * DataWidth) +
                                              (Left + HPosition + column));

                                    increment++;
                                }
                            }

                            //Normalize the Gaussian kernel to the sum of all the gaussian
                            //values in the kernel that do not correspond to a NaN value in
                            //either the background NaN mask or the window NaN mask. Then,
                            //multiply by the SNR window. If the user is not using SNR
                            //filterData, then the SNR window has been filled with 1.0 earlier.
                            //Use SSE (exclude SSE3 summing across register instruction):
                            float GaussianNormalizationTerm = 0.0f;
                            for (int x = 0; x < NumberOfWindowElements; x += 4) {
                                //Combine NaN masks with bitwise AND operation. Just use the
                                //nanWindowVec variable:
                                nanWindowVec =
                                        _mm_and_ps(_mm_load_ps(NaNMaskWindow + x), _mm_load_ps(NaNMaskBackground + x));

                                //Compute product of the sliding window SNR and the background
                                //window SNR:
                                snrWindowVec =
                                        _mm_mul_ps(_mm_load_ps(SNRSlidingWindow + x),
                                                   _mm_load_ps(SNRBackgroundWindow + x));

                                //Multiply the NaN mask and the SNR product, then multiply
                                //this by the Gaussian to filter/weight with NaN/SNR.
                                //Remember - all SNR values are preloaded with 1.0f if user
                                //is not using SNR filterData:
                                gaussianVec =
                                        _mm_mul_ps(_mm_load_ps(GaussianWindow + x),
                                                   _mm_mul_ps(nanWindowVec, snrWindowVec));

                                //Store this result to the gaussian buffer for use later, and
                                //extract and sum (no SSE3) to normalize:
                                _mm_store_ps(Register, gaussianVec);//for accumulation
                                _mm_store_ps((NaNSNRNormalizedGaussian + x), gaussianVec);//For final normalization.

                                //Accumulate:
                                GaussianNormalizationTerm +=
                                        (*(Register) + *(Register + 1) + *(Register + 2) + *(Register + 3));
                            }

                            //Now we have to check to make sure that the gaussian array doesn't consist
                            //of zeros. This is only a concern if the user has opted to exclude the
                            //central value during the processing operation, so check for
                            //that condition first:
                            if (CenterPointInclusive < 1) {
                                //They are excluding the center point, so we have to
                                //check the gaussian and make sure all the elements
                                //sum up to more than zero:
                                int increment = 0;
                                float AccumulatedGaussian = 0.0f;
                                for (int a = 0; a < WindowSize; a++) {
                                    for (int b = 0; b < WindowSize; b++) {
                                        AccumulatedGaussian += *(NaNSNRNormalizedGaussian + increment);
                                        increment++;
                                    }
                                }

                                if (AccumulatedGaussian == 0.0f) {
                                    //Reset the gaussian center point to 1.0f. That means
                                    //that for this particular filterData point in the search area
                                    //it is as if the user has opted to include the center point
                                    //value. This avoids the situation where you have a gaussian
                                    //matrix consisting only of zeros:
                                    *(NaNSNRNormalizedGaussian + GaussianCenterOffset) = 1.0f;

                                    //Change the normalization term to 1.0f to reflect the change:
                                    GaussianNormalizationTerm = 1.0f;
                                }
                            }

                            //Loop through the gaussian buffer and normalize with the above
                            //term (don't bother checking for zeros, just compute):
                            gaussianSum = _mm_load1_ps(&GaussianNormalizationTerm);//Populate vector
                            for (int x = 0; x < NumberOfWindowElements; x += 4) {
                                //Final normalization:
                                gaussianVec =
                                        _mm_div_ps(_mm_load_ps(NaNSNRNormalizedGaussian + x), gaussianSum);

                                //Store:
                                _mm_store_ps((NaNSNRNormalizedGaussian + x), gaussianVec);
                            }

                            //Initialize the iterations sum variable:
                            //IterationsSum = 0.0f;
                            IterationsSum = _mm_load_ss(&Zero);

                            //Store the original noisy value (at the center of the background window):
                            OriginalNoisyValue =
                                    *(UnfilteredData + ((Top + VPosition + EdgeWidth) * DataWidth) +
                                      (Left + HPosition + EdgeWidth));

                            //Loop over vectorized window and filter:
                            for (int x = 0; x < NumberOfWindowElements; x += 4) {
                                //Load filterData:
                                filterVec = _mm_load_ps(SlidingWindow + x);
                                backgroundVec = _mm_load_ps(BackgroundWindow + x);

                                //Load NaN-normalized / SNR-weighted gaussian:
                                gaussianVec = _mm_load_ps(NaNSNRNormalizedGaussian + x);

                                //compute difference between window and background:
                                result1 = _mm_sub_ps(filterVec, backgroundVec);

                                //Square the difference and multiply by the gaussian:
                                result2 = _mm_mul_ps(gaussianVec, _mm_mul_ps(result1, result1));

                                //Sum result2 across registers (without using SSE3).
                                //First, store in buffer:
                                _mm_store_ps(Register, result2);
                                Temp = 0.0f;

                                //Accumulate:
                                Temp +=
                                        (*(Register) + *(Register + 1) + *(Register + 2) + *(Register + 3));

                                //Add iteration sum to running sum:
                                //IterationsSum += Temp;
                                IterationsSum = _mm_add_ss(IterationsSum, _mm_load_ss(&Temp));

                            }//End of window element loop.

                            //Next step is to compute the weight value according to
                            //the user selection:

                            if (WeightingType == 1)//Standard
                            {
                                float temp;
                                _mm_store_ss(&temp, _mm_mul_ss(coefficient, IterationsSum));
                                WeightValue = expf(temp);
                            } else if (WeightingType == 2)//Bisquare
                            {
                                //float r = sqrt(IterationsSum);
                                float r;
                                _mm_store_ss(&r, _mm_sqrt_ss(IterationsSum));

                                //compare against the noise parameter value "h":
                                float hCompare;
                                _mm_store_ss(&hCompare, h);

                                if (r <= hCompare) {
                                    //Compute weight via Bisquare method:
                                    __m128 Term = _mm_sub_ss(One, _mm_div_ss(IterationsSum, hSquared));
                                    _mm_store_ss(&WeightValue, _mm_mul_ss(Term, Term));
                                } else {
                                    //Set to zero:
                                    WeightValue = 0.0f;
                                }
                            } else //Modified Bisquare
                            {
                                //float r = sqrt(IterationsSum);
                                float r;
                                _mm_store_ss(&r, _mm_sqrt_ss(IterationsSum));

                                //compare against the noise parameter value "h":
                                float hCompare;
                                _mm_store_ss(&hCompare, h);

                                if (r <= hCompare) {
                                    //Compute weight via Modified Bisquare method:
                                    float Term;
                                    _mm_store_ss(&Term, _mm_sub_ss(One, _mm_div_ss(IterationsSum, hSquared)));
                                    WeightValue = pow(Term, 8);
                                } else {
                                    //Set to zero:
                                    WeightValue = 0.0f;
                                }
                            }

                            //Check for linear fit option:
                            if (UsingLinearFitOption)
                            {
                                //Compute/accumulate the coefficients:
                                float Coefficient1 = WeightValue * ((float) HPosition);
                                float Coefficient2 = WeightValue * ((float) VPosition);

                                //Accumulate and store values in the "A" matrix (array, actually):
                                A[0] += Coefficient1 * ((float) HPosition);
                                A[1] += Coefficient1 * ((float) VPosition);
                                A[2] += Coefficient1;
                                A[4] += Coefficient2 * ((float) VPosition);
                                A[5] += Coefficient2;
                                A[8] += WeightValue;
                                A[3] = A[1];
                                A[6] = A[2];
                                A[7] = A[5];

                                //Accumulate and store values in the "B" vector:
                                B[0] += Coefficient1 * OriginalNoisyValue;
                                B[1] += Coefficient2 * OriginalNoisyValue;
                                B[2] += WeightValue * OriginalNoisyValue;

                                //Check the weight value against the threshold:
                                if (WeightValue > MinimumWeightThreshold) {
                                    NumberOfWeightsAboveThreshold++;//Increment counter.
                                }

                            }//end of "if UsingLinearFitOption" block.
                            else {
                                //Store to WeightSum:
                                WeightValueSum += WeightValue;

                                //Compute the ScalarValue3 running total for this filtering position:
                                ScalarValue3Sum += (WeightValue * OriginalNoisyValue);
                            }//end of "else averaging" block.

                        }//End of "if CenterValue > 0.0f" block.

                    }//End of "for(int HPosition = 0; ... "
                }//End of "for(int VPosition = 0; ..."


                //check for linear regression fit option:
                if (UsingLinearFitOption)
                {
                    std::cout<< "Linear Regression fit option is not supported !!"<<std::endl;
//                    if (NumberOfWeightsAboveThreshold >= WeightNumberThreshold) {
//                        float RelativeXcoord = (float) ((Column + EdgeWidth) - (Left + EdgeWidth));
//                        float RelativeYcoord = (float) ((Row + EdgeWidth) - (Top + EdgeWidth));
//
//                        // Solve the system of 3 linear equations. First,
//                        // perform the SV-decomposition on the "A" matrix. Intel
//                        // only supplies double-precision version of this operation:
//                        IppStatus returnStatus = ippsSVD_64f_D2((const Ipp64f *) A, U, 3, W, V, 3, 3, svdIterations);
//
//                        // Check the return status for the above operation and see if it
//                        // has converged:
//                        bool functionConverged = true;
//                        if (returnStatus == ippStsSVDCnvgErr) {
//                            // Function has failed to converge after the default number
//                            // of iterations. Increase the number of iterations, loop,
//                            // check, repeat if necessary:
//                            functionConverged = false;
//                            int maxNumberOfIterationsToTry = svdIterations * svdIterationsMaxMultiple;
//                            int currentNumberOfIterations = svdIterations * 2;
//
//                            while ((currentNumberOfIterations <= maxNumberOfIterationsToTry) && !functionConverged) {
//                                // Try again with new number of iterations:
//                                returnStatus = ippsSVD_64f_D2((const Ipp64f *) A, U, 3, W, V, 3, 3,
//                                                              currentNumberOfIterations);
//
//                                // Check for convergence:
//                                if (returnStatus == ippStsSVDCnvgErr) {
//                                    // Increase the number of iterations to try:
//                                    currentNumberOfIterations += svdIterations;
//                                } else {
//                                    // Function converged. Set the bool:
//                                    functionConverged = true;
//                                }
//                            }
//                        }
//
//                        // Check for convergence:
//                        if (functionConverged) {
//                            // Check the diagonal values of the "W" array resulting from
//                            // the above SVD operation. If they are smaller than our
//                            // epsilon value, assign zero. Otherwise, invert:
//                            if (W[0] < svd_W_epsilon) {
//                                W[0] = 0.0;
//                            } else {
//                                W[0] = 1.0 / W[0];
//                            }
//                            if (W[1] < svd_W_epsilon) {
//                                W[1] = 0.0;
//                            } else {
//                                W[1] = 1.0 / W[1];
//                            }
//                            if (W[2] < svd_W_epsilon) {
//                                W[2] = 0.0;
//                            } else {
//                                W[2] = 1.0 / W[2];
//                            }
//
//                            // Load these values into Wt vector:
//                            Wt[0] = W[0];
//                            Wt[4] = W[1];
//                            Wt[8] = W[2];
//
//                            // Take the transpose of the U matrix:
//                            returnStatus = ippmTranspose_m_64f((const Ipp64f *) U, srcStride1_64, srcStride2_64,
//                                                               3, 3, U_transposed, srcStride1_64, srcStride2_64);
//
//                            // Multiply the V matrix by the Wt matrix:
//                            returnStatus = ippmMul_mm_64f((const Ipp64f *) V, srcStride1_64, srcStride2_64, 3, 3,
//                                                          (const Ipp64f *) Wt, srcStride1_64, srcStride2_64, 3, 3,
//                                                          Temp1, srcStride1_64, srcStride2_64);
//
//                            // Multiply the result from the above operation by the U transpose:
//                            returnStatus = ippmMul_mm_64f((const Ipp64f *) Temp1, srcStride1_64, srcStride2_64, 3, 3,
//                                                          (const Ipp64f *) U_transposed, srcStride1_64, srcStride2_64,
//                                                          3, 3,
//                                                          Temp2, srcStride1_64, srcStride2_64);
//
//                            // Multiply the result of the above operation by the "B" vector to
//                            // get our equation coefficients:
//                            returnStatus = ippmMul_mv_64f((const Ipp64f *) Temp2, srcStride1_64, srcStride2_64, 3, 3,
//                                                          (const Ipp64f *) B, srcStride2_64, 3,
//                                                          X, srcStride2_64);
//
//
//                            //Compute and store final value using these coefficients
//                            //and the relative (search area) coordinate of the filterData
//                            //point being filtered:
//                            *(FilteredData + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth)) =
//                                    ((float) X[0] * RelativeXcoord) + ((float) X[1] * RelativeYcoord) + (float) X[2];
//
//                        }// End of "if function converged" block.
//
//                        else
//                        {
//                            //Compute using simplified method:
//                            *(FilteredData + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth)) = (float) (B[2] /
//                                                                                                                A[8]);
//                        }
//
//                    } // End of "if NumberOfWeightsAboveThreshold >= WeightNumberThreshold" block.
//
//
//                    else {
//                        //Compute using simplified method:
//                        *(FilteredData + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth)) = (float) (B[2] /
//                                                                                                            A[8]);
//                    }
//
                }//End of "if UsingLinearFit" block.
                else {
                    //Compute and store final result:
                    *(FilteredData + ((Row + EdgeWidth) * DataWidth) + (Column + EdgeWidth)) =
                            (float) (ScalarValue3Sum / WeightValueSum);
                }//End of averaging lock.

            }//End of "if (NanMask[][] == 1.0f) && SNR > 0.0f " block.

            else {
                //Store a NaN at this location since there is either
                //a NaN in the original filterData or the SNR is too low:
                *(FilteredData + ((Row + EdgeWidth) * DataWidth) +
                  (Column + EdgeWidth)) = std::numeric_limits<float>::quiet_NaN();
            }

        }//End of scanline loop (int Column = 0;...).

        //Get the next scanline for processing:
        #pragma omp critical
        {
            CurrentScanline = synchronizationCounter;
            synchronizationCounter++;
        }

    }//End of filtering loop (while CurrentScanline <= ...).

    //Deallocate memory here:
    _mm_free(SlidingWindow);
    _mm_free(NaNMaskWindow);
    _mm_free(BackgroundWindow);
    _mm_free(GaussianWindow);
    _mm_free(NaNSNRNormalizedGaussian);
    _mm_free(NaNMaskBackground);
    _mm_free(Register);
    _mm_free(SNRBackgroundWindow);
    _mm_free(SNRSlidingWindow);
}


//void CNLMFilter::StoreInputArrayPtr_8bit(unsigned char *inputPtr) {
//    //Store the array pointer:
//    InputData_8 = inputPtr;
//}
//
//void CNLMFilter::StoreInputArrayPtr_16bit(unsigned short *inputPtr) {
//    //Store the input array pointer:
//    InputData_16 = inputPtr;
//}
//
//void CNLMFilter::StoreOutputArrayPtr_8bit(unsigned char *outputPtr) {
//    //Store the output array pointer:
//    OutputData_8 = outputPtr;
//}
//
//void CNLMFilter::StoreOutputArrayPtr_16bit(unsigned short *outputPtr) {
//    //Store the output array pointer:
//    OutputData_16 = outputPtr;
//}
//

//void CNLMFilter::StoreInputArrayPtr_Double(double *inputPtr) {
//    //Store the pointer to the input array:
//    InputData_D = inputPtr;
//}
//
//void CNLMFilter::StoreOutputArrayPtr_Double(double *outputPtr) {
//    //Store the output array pointer:
//    OutputData_D = outputPtr;
//}
//
//void CNLMFilter::StoreSNRArrayPtr_Double(double *snrPtr) {
//    //Store the SNR array pointer:
//    SNR_D = snrPtr;
//}
//
//unsigned char *CNLMFilter::GetInputArrayPtr_8bit() {
//    return InputData_8;
//}
//
//unsigned char *CNLMFilter::GetOutputArrayPtr_8bit() {
//    return OutputData_8;
//}
//
//unsigned short *CNLMFilter::GetOutputArrayPtr_16bit() {
//    return OutputData_16;
//}
//
//unsigned short *CNLMFilter::GetInputArrayPtr_16bit() {
//    return InputData_16;
//}
//
//double *CNLMFilter::GetOutputArrayPtr_Double() {
//    return OutputData_D;
//}
//
//double *CNLMFilter::GetInputArrayPtr_Double() {
//    return InputData_D;
//}

